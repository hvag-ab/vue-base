
标准文档流
所谓的文档流，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。
宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作是个“流”，必须从上而下。而设计软件想往哪里画个东西，都能画。

标准文档流里的一些微观现象。
1、空白折叠现象。
比如，如果我们想让img标签之间没有空隙，必须紧密连接。
<img src="images/1.jpg"><img src="images/2.jpg"/><img src="images/3jpg"/>
2、高矮不齐，底边对其。
3、自动换行，一行写不满，换行写。


块级元素和行内元素

标准文档流等级森严，标签分为两种等级。

块级元素
块级元素的特点：

（1）每个块元素霸占一行

（2）高度，行高、外边距以及内边距都可以控制。

（3）宽度默认是容器的100%

（4）可以容纳内联元素和其他块元素。

行内元素
行内元素的特点：

（1）和相邻行内元素在一行上 行内元素并列一排。

（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。

（3）默认宽度就是它本身内容的宽度。

（4）行内元素只能容纳文本或则其他行内元素。（a特殊）


行内块元素（inline-block）
在行内元素中有几个特殊的标签——<img />、<input />、<td>，<button>可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。

行内块元素的特点：
（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。
（2）默认宽度就是它本身内容的宽度。
（3）高度，行高、外边距以及内边距都可以控制。


在HTML中，已经将标签进行分过类，文本级和容器级。

文本级：p、span、a、b、i、u、s、em、strong、del、ins。。。。
容器级：div、h系列、ul、ol、li、dl、dt、dd。。。。

所有的文本级都是行内元素；除了p，p是文本级，但是是一个块级元素。
所有的容器级都是块级元素。


标签显示模式转换 display
块转行内：display:inline;
特点:
使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行.
不能更改元素的height，width的值，大小由内容撑开.
可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行.

行内转块：display:block;
特点：
使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度.
能够改变元素的height，width的值.
可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果.

块、行内元素转换为行内块： display: inline-block;
特点：
使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行 但是元素之间存在间隙 不同于float浮动 不存在间隙
但是float会导致元素之间参差不齐的现象 inline-block则不会 会以底部对齐方式排列.
去除空隙的方法：
　　1.对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙
能够改变元素的height，width的值.
可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果.


标准文档流里面限制非常地多，标签的性质比较恶心，如果，我想既能设置宽高，又让其能并排（不霸占一行），这时候就要去脱离标准文档流。

CSS中有三种手段，使一个元素脱离标准文档流。

4.浮动
4.7 float属性
选择器{float:属性值;}
left	元素向左浮动
right	元素向右浮动
none	元素不浮动（默认值）
浮动的目的就是为了让多个块级元素同一行上显示。

基本浮动规则

非完全脱离文档流
左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。一个使用浮动一个没有导致DIV不是在同个“平面”上，但内容不会造成覆盖现象，只有DIV形成覆盖现象。

示例代码：

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        *{
            margin: 0;
        }

        .r1{
            width: 100px;
            height: 100px;
            background-color: #7A77C8;
            float: left;
        }
        .r2{
            width: 200px;
            height: 200px;
            background-color: wheat;

        }
    </style>
</head>
<body>

<div class="r1"></div>
<div class="r2">region2</div>
</body>
</html>
>>>解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。


收缩

即一个浮动的元素，如果没有设置width，那么将自动收缩为文字的宽度（非常像行内元素）。

比如：

未浮动默认宽度为父亲的100%

<style type="text/css">
	div{
		background-color: pink;
	}
</style>

浮动

<style type="text/css">
	div{
		float: left;
		background-color: pink;
	}
</style>

4.9.1
清除浮动本质
清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。
清除浮动的方法
其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。
浮动元素脱离标准文档流会出现边框塌陷

在CSS中，clear属性用于清除浮动，其基本语法格式如下：

选择器{clear:属性值;}
left	不允许左侧有浮动元素（清除左侧浮动的影响）
right	不允许右侧有浮动元素（清除右侧浮动的影响）
both	同时清除左右两侧浮动的影响

父级添加overflow属性方法
可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解）
可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。

使用after伪元素清除浮动
:after 方式为空元素的升级版，好处是不用单独加标签了

使用方法：
.clearfix:after {  content: "."; display: block; height: 0; clear: both; visibility: hidden;  }

使用before和after双伪元素清除浮动
使用方法：


  .clearfix:before,.clearfix:after {
    content:"";
    display:table;  /* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */
  }
  .clearfix:after {
   clear:both;
  }
  .clearfix {
    *zoom:1;
  }
​缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

****重点
父元素高度自适应（边框塌陷）当子元素有浮动并且父元素没有高度的情况下父元素会出现高度塌陷 也就是父元素的边框为了适应子元素而变形
例如 frist子元素添加了float属性 造成的坍塌 可以比较一下不加和添加的区别
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <style type="text/css">
        .box {
            border: 1px solid red;
        }
        .frist {
            width: 200px;
            height: 50px;
            float: left;
            border: 1px solid green;
        }
        .box1 {
            width: 200px;
            height: 80px;
            background: silver;
        }
    </style>
</head>
<body>
    <div class="box">
     box
        <div class="frist">frist</div>
    </div>
    <div class="box1">box1</div>
</body>
</html>

消除坍塌现象
方法一：给父元素添加声明overflow:hidden;(触发一个BFC)
overflow: hidden;

overflow 溢出
检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。

visible : 　不剪切内容也不添加滚动条。

auto : 　 超出自动显示滚动条，不超出不显示滚动条

hidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉

scroll : 　不管超出内容否，总是显示滚动条

方法二: 在浮动元素下方添加空div,并给该元素添加声明：div{clear:both; height:0; overflow:hidden;} （这样会多一个空的div增加代码长度）

    .k{clear:both; height:0; overflow:hidden;}
    <div class="k"></div>

方法三:添加CSS样式中伪元素after(格式如下，有些复杂)

 :after {
   content: "";
   clear: both;
   display: block;
   height: 0;
   overflow: hidden;
   visibility: hidden;
   }

方法四：给父元素添加浮动（方便简洁,不是很规范)

 float: left;




定位

position属性的常用值

值	描述
static	自动定位（默认定位方式）  就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性
relative	相对定位，相对于其原文档流的位置进行定位（相对于块级元素（或行内块）自身位置进行定位）
absolute	绝对定位，相对于离它最近的一个已定位的盒子进行定位的（默认是body）
fixed	固定定位，相对于浏览器窗口进行定位

1、绝对定位元素溢出父元素，怎么隐藏问题？

　　通常，为了让DIV子元素超出部分隐藏，都是在父元素设置overflow:hidden，这样即可防止子元素撑开父元素，使子元素能够溢出隐藏！

　　但是，对于position:absolute定位的子元素，仅仅使用overflow:hidden没办法将其溢出部分隐藏，需要在父元素上也加上一个定位position:relative;才能将含有position:absolute属性的子元素进行溢出隐藏

1.绝对定位：可以通过top、right、bottom和left属性把元素定位到文档的任何位置。元素会脱离文档流，如果设置偏移量，会影响其他元素的位置定位
说明：元素在没有定义宽度的情况下，宽度由元素里面的内容决定，效果和用float方法一样。
#object {
    position:absolute;
    top:100px;
    left:200px;
}
2.相对定位：相对于对象在文档中原来的位置来移动对象。 相对定位是将元素相对于它在标准流中的位置进行定位，元素设置此属性之后仍然处在文档流中，不影响其他元素的布局
说明 置了relative的元素仍然处在文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置。最外层容器设置为relative定位，在没有设置宽度的情况下，宽度是整个浏览器的宽度。
#object {
    position:relative;
    top:10px;
    left:10px;
}
3.固定定位：将对象移动到一个绝对位置上，当文档滚动时，该对象仍会保持在它原始的位置上，而主文档在它下面滚动。

#object{
    position:fixed;
    top:0px;
    left:0px;
}

叠放次序（z-index）
当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。


在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。

比如：  z-index: 2;

注意：

z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。

如果取值相同，则根据书写顺序，后来居上。

后面数字一定不能加单位。

只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。

定位模式转换
跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式，

** 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。**




transform
transform属性实现了一些可用SVG实现的同样的功能。它可用于内联(inline)元素和块级(block)元素。它允许我们旋转、缩放和移动元素 ，他有几个属性值参数：rotate;translate;scale;skew;matrix。下面我们分别来介绍这几个属性值参数的具体使用方法：
语法：

transform ： none |[]* 也就是： transform: rotate | scale | skew | translate |matrix;
一、旋转rotate

rotate() ：通过指定的角度参数对原元素指定一个2D rotation（2D 旋转），需先有transform-origin属性的定义。
transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。
如：transform:rotate(30deg）

二、移动translate

移动translate我们分为三种情况：translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）；translateX(x)仅水平方向移动（X轴移动）；translateY(Y)仅垂直方向移动（Y轴移动），具体使用方法如下：

1、translate([, ]) ：通过矢量[tx, ty]指定一个2D translation，tx 是第一个过渡值参数，ty 是第二个过渡值参数选项。
如果未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，
反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如transform:translate(100px,20px):
transform:translate(-50%,-50%):移动自身x y轴的长度和宽度

image
2、translateX() ： 通过给定一个X方向上的数目指定一个translation。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置。如：transform:translateX(100px):

image
3、translateY() ：通过给定Y方向的数目指定一个translation。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。如：transform:translateY(20px):

缩放scale

缩放scale和移动translate是极其相似，他也具有三种情况：scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；scaleX(x)元素仅水平方向缩放（X轴缩放）；scaleY(y)元素仅垂直方向缩放（Y轴缩放），但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。下面我们具体来看看这三种情况具体使用方法：

1、scale([, ])：提供执行[sx,sy]缩放矢量的两个参数指定一个2D scale（2D缩放）。如果第二个参数未提供，则取与第一个参数一样的值。scale(X,Y)是用于对元素进行缩放，可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：transform:scale(2,1.5):

image
2、scaleX() ： 使用 [sx,1] 缩放矢量执行缩放操作，sx为所需参数。scaleX表示元素只在X轴(水平方向)缩放元素，他的默认值是(1,1)，其基点一样是在元素的中心位置，我们同样是通过transform-origin来改变元素的基点。如：transform:scaleX(2):

image
3、scaleY() ： 使用 [1,sy] 缩放矢量执行缩放操作，sy为所需参数。scaleY表示元素只在Y轴（垂直方向）缩放元素，其基点同样是在元素中心位置，可以通过transform-origin来改变元素的基点。如transform:scaleY(2):


4.11 CSS伪类

有一些选择器和和类只能用在样式表中，在HTML中没有对应的标记或属性。它们的任务时使用除名称、属性或内容以外 的其他特征来对元素进行分类。
伪类使用一个冒号":"与元素分离，常用的伪类像：first-line、first-child、first-letter、link、hover、active、visited等。

链接伪类选择器
:link      /* 未访问的链接 */

:visited   /* 已访问的链接 */

:hover     /* 鼠标移动到链接上 */

:active    /* 选定的链接 */

复制代码
.bigfirst:first-letter{
    font-size:400%;
    float:left; }

a:link {color:blue; }
a:visited { color:linghtblue; }
a:hover {   /* :hover 是链接伪类选择器 鼠标经过 */
              color: red; /*  鼠标经过的时候，由原来的 灰色 变成了红色 */
  }


结构(位置)伪类选择器（CSS3)
:first-child :选取属于其父元素的首个子元素的指定选择器
E::first-letter文本的第一个单词或字（如中文、日文、韩文等）
E::first-line 文本第一行；
E::selection 可改变选中文本的样式；
:last-child :选取属于其父元素的最后一个子元素的指定选择器

:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型

:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式

li:first-child { /*  选择第一个孩子 */
          color: pink;
      }
li:last-child {   /* 最后一个孩子 */
          color: purple;
      }
li:nth-child(4) {   /* 选择第4个孩子  n  代表 第几个的意思 */
          color: skyblue;
      }
p::first-letter {
    font-size: 20px;
    color: hotpink;
  }
  ​
  /* 首行特殊样式 */
  p::first-line {
    color: skyblue;
  }
  ​
  p::selection {
    /* font-size: 50px; */
    color: orange;
  }

4、E::before和E::after

在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。


  div::befor {
    content:"开始";
  }
  div::after {
    content:"结束";
  }


目标伪类选择器(CSS3)
:target目标伪类选择器 :选择器可用于选取当前活动的目标元素


:target {
  color: red;
  font-size: 30px;
}

CSS注释
  CSS规则是使用     /*  需要注释的内容  */  进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。
  p {
    font-size: 14px;                 /* 所有的字体是14像素大小*/
  }



另一个有趣的动态伪类时focus，只有当用户通过键盘或鼠标时某个元素获得焦点时它才起作用。

*:focus { backgroup-color:blue; }
伪元素是一种将内容而不是样式添加到元素的方法，同样在元素后面加冒号":"并附带一个伪元素就可以使用了。

例如，在offer元素前放置一些脚本或在链接后放置一张图片：

.offer:before { content='Special Offer!'; }
a:after { url(link.gif;) }

